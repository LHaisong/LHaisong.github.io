layout:     post
title:      ReentrantLock和Synchronized
subtitle:   原理、区别、使用
date:       2019-05-06
author:     LHaisong
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - java并发
    

# 原子操作的实现原理

32位的IA-32处理器使用了基于总线加锁或缓存加锁的方式来实现多处理器之间的原子操作，在简单的情况下一个处理利器能保证内存操作的原子性（从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取或者写入一个字节时其它处理器是不能访问这个字节的内存地址的）；在复杂情况下使用总线锁定和缓存锁定来保证复杂操作的原子性

- 通过总线锁定保证原子性：使用处理器的一个LOCK#信号实现，当一个处理器在总线上输出此信号时，其它处理器的请求将被阻塞住，那么该处理器就独占共享内存

- 使用缓存锁定保证原子性：总线锁定的开销是比较大的，因为它把CPU与内存之间的通信方式锁住了，导致其它的内存地址也不能访问；缓存锁定指的是内存区域如果被缓存在处理器的缓存中，并且在Lock期间被锁住，那么当它执行所操作回写到内存时，处理器不在总下上声言LOCK#信号，而是修改内存地址，并通过缓存一致性协议保证原子性，因为缓存一致性协议会阻止同时修改由两个或以上处理器缓存的内存区域；下面两种情况不会使用缓存锁定：

  > 1.操作数据不能被缓存在处理器内部，或者操作的数据跨越多个缓存行
  >
  > 2.处理器不支持缓存锁定
  >
  > 以上两种情况下会调用总线锁定

# java原子操作的实现原理

java实现原子操作的方式有锁机制和CAS

- 使用CAS实现原子操作：利用处理器提供的CMPXCHG指令实现；自旋CAS实现的基本思路是循环进行直到成功为止。CAS操作存在的问题：

  > 1.ABA问题：一个值原来是A，变成了B，又变成了A，CAS检测时会认为A没有变化但实际上是变化的；可使用版本号解决这个问题，从JDK1.5开始提供了AtomicStampedReference这个类来解决ABA问题
  >
  > 2.循环时间长开销大：自旋CAS如果长时间不能成功会给CPU带来很大的执行开销
  >
  > 3.只能有一个变量的原子操作：当有多个变量时，循环CAS无法保证操作的原子性，JDK提供了AtomicReference类来保证多个CAS操作的原子性

- 使用锁实现原子性：锁机制保证了只有获得锁的线程才能操作锁定的内存区域
