---
layout:     post
title:      类加载机制
subtitle:   类加载机制
date:       2019-05-20
author:     LHaisong
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - jvm
---

## 类加载的时机

遇到下面的几种情况时必须加载：

- 遇到new、getstatic、putstatic、invokestatic（实例化对象、获取静态变量、设置静态变量、执行静态方法）这4条指令时必须加载，如果没有初始化，则触发初始化
- 使用java.lang.reflect包的方法对类进行反射调用的时候，没有初始化则会触发类的初始化
- 初始化一个类的时候如果其父类没有初始化，则会触发父类的初始化
- 虚拟机启动实话，用户指定一个要执行的类（包含main方法），虚拟机优先初始化
- jdk动态语言支持时

## 类加载的过程

- 加载：

  > 1.通过类的全限定名获取定义此类的二进制字节流
  >
  > 可能的来源：zip包（成为jar，war格式的基础），从网络中获取applet
  >
  > 2.将这个二进制字节流对应的静态存储结构转换为方法区的运行时数据结构
  >
  > 3.在内存中生成代表这个类的java.lang.class 对象作为这个类的数据访问入口

- 验证：确保class文件符合虚拟机规范的要求，不会影响虚拟机的安全

  > 文件格式验证：验证字节流是否符合class文件规范
  >
  > 元数据验证：对字节码进行语义分析，验证是否符合java语言规范
  >
  > 字节码验证：确定程序语义是合法的、符合逻辑的
  >
  > 符号引用验证：信息匹配校验

- 准备：正式为类变量（static修饰，不包括实例变量）分配内存并设置初始系统要求的值

- 解析：将常量池中的引用替换为直接引用

- 初始化：根据程序员的要求去初始化类变量和其他资源（执行类构造器<cinit()>方法的过程）

![](https://res.cloudinary.com/dzdyb9ta5/image/upload/v1567046709/img/34_uhnvui.png)



## 类加载器

> 类加载器只用于类的加载动作，对于任何一个类都需要由加载它的类加载器和它本身共同确定它在虚拟机中的唯一性,要想判断虚拟机中的两个类是否相等，首先必须是由同一个类加载器加载的，即使两个类来自同一个class文件，只要加载器不同，两个类就不可能相等

- 类加载器的种类

  1.启动类加载器（bootstrap）：负责将java_home/lib下的类加载到内存中，这在虚拟机层面实现，开发者不可直接引用

  2.扩展类加载器（extension）：由Sun公司的ExtClassLoader实现，负责加载java_home/lib/ext中的类，开发者可以直接使用

  3.应用程序类加载器(Application):由Sun公司的APPClassLoader实现，，它负责将classpath路径下的类加载到内存中，开发者可以直接使用

  4.自定义类加载器：用户自定义

- 双亲委派模型：

  > 指的是当一个类收到加载请求时，他不会首先自己加载这个类，而是把这个请求委派给父类加载器去完成，依次向上推，所以所有的类加载请求都会传到启动类加载器，当顶层的加载器无法完成加载请求时，才会尝试让子类加载器去完成加载请求
  >
  > 优点：java类随着它的加载器具备了优先级层次关系，保证了程序的稳定运行

  ![](https://res.cloudinary.com/dzdyb9ta5/image/upload/v1567046769/img/35_x1ziod.png)
