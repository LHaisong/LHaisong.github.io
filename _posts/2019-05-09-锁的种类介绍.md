---
layout:     post
title:      锁
subtitle:   乐观锁、悲观锁、公平锁、非公平锁
date:       2019-05-08
author:     LHaisong
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - java并发
---

## 锁的种类介绍
### 公平锁与非公平锁：
- 公平锁：各个线程按照申请锁的顺序获取锁
- 非公平锁：多个线程申请获得锁时，锁的获得与申请的顺序无关，有可能会造成优先级反转，但是吞吐量大;ReentrantLock默认是非公平锁，但是也可以转换为公平锁，synchronized是非公平锁

### 乐观锁与悲观锁：并不是某一特定的锁，而是指一种设计方法
- 乐观锁：默认不会发生并发安全问题，也就是说假设对数据的操作并没有发生修改。在更新数据的时候采用不断尝试更新的方法，知道更新成功。乐观锁适合读特别多的场景，常见的乐观锁有CAS算法(java包中的原子类实现原理),数据库中通过版本号实现数据的并发访问;但是乐观锁也存在以下问题：
1. CAS算法的ABA问题，初次读取变量的值是A，要修改的时候发现仍然是A，那么CAS就会认为A没有被修改过，其实这是不正确的
2. 循环时间开销大，自旋CAS如果长时间无法成功则会给CPU带来极大的开销
3. CAS只对单个变量有效，当涉及多个变量时无效，JDK1.5以后可以利用AtomicReference把多个变量放在一个对象里进行CAS操作

- 悲观锁：默认并发情况下一定会发生数据的更新，哪怕不会发生更新，它也会认为会发生更新，所以会对数据采取加锁。悲观锁适合写操作非常多的情景，synchronized、ReentrantLock都是悲观锁;另外，传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
1. 悲观锁最大的问题就是在操作数据前必须先加锁，所以导致了并发程度不高，而适用于写操作比较多的场景

### 独占锁和共享锁
- 独占锁：指锁一次只能被一个线程获取;常见的synchronized、ReentrantLock都是独占锁
- 共享锁：指锁能被多个线程获取;JUC包下ReadWriteLock的读锁是共享锁，但是其写锁是独占锁

### 可重入锁
- 可重入锁：当一个线程获取一个对象的锁后，再次请求获取该对象的锁时会请求成功，synchronized、ReentrantLock都是可重入锁

### 偏向锁/轻量级锁/重量级锁
- 这3种锁是JVM对Synchronized的优化
