---
layout:     post
title:      HashMap
subtitle:   HashMap必知必会
date:       2019-05-05
author:     LHaisong
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - Collections
---  
## 1.什么是hashmap，hashmap的原理及内部数据结构？  
> 在jdk1.8中hashmap采用了数组+链表+红黑树这3中数据结构实现  
## 2.hashmap中put方法的过程？  
> 根据要加入的对象e*计算hash值*，根据(cap-1)&hash计算要加入的位置i，判断数组该位置处有没有元素，没有则直接把元素放在该位置即可；如果*存在冲突（该位置处已经有元素p）*，计算p的hash值与key是否与e相同，想相同则直接覆盖；如果p是一个TreeNode，则按照TreeNode的方法加入元素；否则如果前面都不满足，遍历链表直到找到一个插入点，同时也会计算是否满足值覆盖条件；插入后要检查是否满足转化为红黑树的条件（链表长度>64，直接转化；8<长度<64，则扩容）。  
## 3.hashmap中对象的hash值是怎么计算的？还有哪些实现hash的方式？ 
> 首先计算出hashcode的值，然后与自身低16位做异或运算；计算hash的方式：计算hashcode所用的方法是除法散列法；平方散列法，index=（val*val）>>28;斐波那契散列法，与平方散列法类似，利用斐波那契数列求得一个理想的乘数。  
## 4.处理hash冲突的办法？  
> hashmap所用数组+链表的方式是拉链法；再散列，遇到hash冲突时，重新计算；线性探测法，把元素加入位置i发生冲突时,hash=(hash+1)%m从i开始向后查找hash表，直达找到一个没有冲突的位置存放元素；线性补偿探测法，对线性探测法进行改进，hash=（hash+Q）%M,M与Q互质；伪随机探测法，将线性探测法中的1换成一个随机数，这样可以避免堆聚。  
## 5.hashmap的扩容过程？  
> hashmap整个扩容过程可以分为两步：即扩容和数据迁移
在扩容阶段会进行几个容量的判断，如是不是第一次扩容？直接初始化为默认容量16；是否指定容量或者阈值;是否达到了最大容量2^31？  
数据迁移阶段逐个遍历数组，利用元素的hash值和新容量计算在新数组中的位置i=e.hash & (newCap - 1),如果原数组中该位置没有发生过碰撞，则直接把元素放在新数组中的指定位置即可；但是如果发生过碰撞呢？先要判断是否进行过红黑树的转换，是的话要按照红黑树的方法进行迁移；由于扩容后容量变为了2倍，比如说原来的容量是16，15->01111,在这种情况下hash&01111的高位只能为0；但是容量变为32 31->11111 高位多出来一个1，所以在进行hash&11111的时候高位可能是1也可能是0，所以数据迁移的时候把这两种情况分开来了，是0的时候直接放在原位置，是1的时候放在<原位置+扩容容量>位置处  
