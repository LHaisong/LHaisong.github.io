---
layout:     post
title:      内存分配与垃圾回收
subtitle:   内存分配与垃圾回收
date:       2019-05-19
author:     LHaisong
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - jvm
---
> java的垃圾回收机制主要需要解决一下几个问题：
>
> 1.什么时候进行垃圾回收？
>
> 2.如何判断哪些对象可以回收？
>
> 3.如何进行垃圾回收？

# 垃圾回收的时机

## 1.java堆区的内存结构

java的堆区可分为新生代区和老年代区；其中新生代又可分为Eden区和survivor区(一般为2块)，内存大小比例为8:1:1(官方实践给出的最优比例)

## 2.为对象分配内存的过程

1.对象首先在Eden区分配，如果Eden去空间不足将会触发Minor GC，对新生代进行回收，回收不活跃对象；如果这个时候空间(新生代)依然不足，将会尝试到老年代分配，老年代空间不足的情况下会触发Full GC。

![30](https://res.cloudinary.com/dzdyb9ta5/image/upload/v1567046513/img/30_cgnp7g.png)

# 回收哪些对象

判断一个对象是否可回收与两种方法：

- 引用计数法：为堆中的每个对象创建一个引用计数器，当有一个地方引用它时计数器加1，引用失效时减1，在任何时刻引用计数器为0的对象可回收；但是对象之间相互引用的时候jvm无法回收对象

- 可达性分析算法：以一系列称为GC-roots的对象为根节点向下搜索，搜索的路径为引用链，当一个对象没有在任何引用链上时是可回收的

  1.可作为GC-roots的对象：

  - 虚拟机栈中的对象
  - 方法区静态类引用的对象
  - 方法区常量引用的对象
  - 本地native方法中引用的对象

  > 在可达性分析中不可达的对象也不是一定会被清除，需要经历至少两次标记，当不可达时会被第一次标记，然后进行一次筛选，判断对象有没有必要执行finalize()方法，如果没必要执行或者该方法已经被执行过，虚拟机会认为没必要执行
  >
  > 虚拟机如果认为对象有必要执行finalize()方法，则会进入F-Queue队列中，等待虚拟机自动创建一个低优先级的Finalizer()线程去执行它

# 如何回收

## 垃圾回收算法

- 标记清除算法：首先标记需要回收的对象，然后统一回收 

  缺点：会产生大量的内存碎片，效率不高

- 复制算法：将内存分为大小相等的两块，每次使用一块，进行垃圾回收时先将存活的对象移到另一块上去，然后对使用的进行回收

- 标记整理算法：标记需要回收的对象，然后让存活的对象都向一端移动，回收边界以外的全部内存

- 分代收集算法：各年代采用合适的算法

采用什么样的垃圾回收算法与垃圾回收器的种类息息相关：

## 垃圾收集器的种类

- Serial收集器（新生代）：单线程收集器，在进行gc的时候需要暂停工作线程（stop the world）

- ParNew收集器（新生代）：Serial收集器的多线程版本（server模式下的首选，能与CMS收集器协调工作）

- Parallel Scavenge收集器（新生代）：该收集器的优点在于可以控制吞吐量[用户代码运行时间/（用户代码运行时间+垃圾回收的时间）]，采用的是复制算法

- Serial Old收集器：serial收集器老年代版本，单线程使用标记-清除算法

- Parallel Old：Parallel Scavenge的老年代版本，多线程使用标记-整理算法

- CMS收集器（老年代）：是一种以获得最短停顿目标的收集器，采用标记清除算法

  1.过程：

  > 初始标记：标记GC roots能关联到的对象，需要STW
  >
  > 并发标记：GC roots追踪
  >
  > 重新标记：修正并发标记阶段因为程序的运行而导致标记发生变化的那部分对象的标记记录，需要STW
  >
  > 并发清除：内存回收，与用户线程并发执行

​                 2.缺点：

> ①无法处理浮动垃圾  
>
> ②对CPU资源敏感  
>
> ③回收效率不高，而且有浮动垃圾产生

- G1收集器：新生代、老年代都可以使用的收集器

  1.特点：

  > 并行与并发：充分利用CPU的资源，缩短STW时间
  >
  > 分代收集：可独自管理整个堆
  >
  > 空间整合：整体上采用的是标记整理算法，局部采用复制算法
  >
  > 可预测停顿：建立可预测模型，预测STW的时间
  >
  > 使用这种收集器时，堆的内存结构发生了变化，将整个堆分为了大小相等的独立区域，但是还保存着新生代和老年代的概念。

  2.过程：

  > 1.初始标记：标记GC-Root能关联到的对象，并修改NTAMS（Next Top at Mark Start）的值，让下一阶段的用户程序并发运行时能在正确的region区域创建对象，需要停顿线程（时间短）
  >
  > 2.并发标记：从GC roots对象开始进行可达性分析，找出存活的对象，耗时长，可与用户程序并发进行
  >
  > 3.最终标记：修正并发标记时由于用户程序的执行而导致标记发生变化的那一部分对象的标记记录，将变化记录在Remember Set Log中
  >
  > 4.筛选回收：对各个region进行回收成本与价值估计，根据用户期望指定回收计划

  ![](https://res.cloudinary.com/dzdyb9ta5/image/upload/v1567046526/img/33_kg4voc.png)
  
## java在堆上分配内存的规则

- 对象优先在新生代Eden区分配，当Eden区没有足够的空间时，虚拟机会触发Minor GC
- 大对象直接进入老年代，可通过一个虚拟机参数设置阈值
- 长期存活的对象直接进入老年代，虚拟机会给每个对象设置一个计数器，经历一场Minor GC年龄就+1，当超过一个阈值的时候将会进入老年代，这个阈值可以用一个虚拟机参数设置


  

