---
layout:     post
title:      Unix5中IO模型
subtitle:   阻塞、非阻塞、多路复用、信号驱动、异步
date:       2019-05-10
author:     LHaisong
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - IO系统
---

## 阻塞IO
- 传统的IO(IO，Socket)都是阻塞IO，在系统发起IO请求后，需要等待数据准备充分，在数据准备阶段进程必须等下来等待
![](https://i.imgur.com/K1B9dil.png)

## 非阻塞IO
- 应用进程发起IO请求与内核交互，数据准备好之前，不再一味的等着，而是直接返回。然后通过轮询的方式，不停的去问内核数据准备有没有准备好。如果某一次轮询发现数据已经准备好了，那就把数据拷贝到用户空间中;
![](https://i.imgur.com/wE8Mogk.png)
应用进程通过 recvfrom 调用不停的去和内核交互，直到内核准备好数据。如果没有准备好，内核会返回error，应用进程在得到error后，过一段时间再发送recvfrom请求。在两次发送请求的时间段，进程可以先做别的事情。

## 信号驱动IO
- 应用进程在读取文件时通知内核，如果某个 socket 的某个事件发生时，请向我发一个信号。在收到信号后，信号对应的处理函数会进行后续处理。
![](https://i.imgur.com/fKnikKu.png)
应用进程预先向内核注册一个信号处理函数，然后用户进程返回，并且不阻塞，当内核数据准备就绪时会发送一个信号给进程，用户进程便在信号处理函数中开始把数据拷贝的用户空间中。  

## 多路复用IO
- 多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。NIO
![](https://i.imgur.com/iwYHsZb.png)
IO多路复用是多了一个select函数，多个进程的IO可以注册到同一个select上，当用户进程调用该select，select会监听所有注册好的IO，如果所有被监听的IO需要的数据都没有准备好时，select调用进程会阻塞。当任意一个IO所需的数据准备好之后，select调用就会返回，然后进程在通过recvfrom来进行数据拷贝。

## 同步IO与异步IO
- 同步IO：严格上来说上面的4种IO模型都是属于同步IO，因为当数据准备好之后都需要进程执行recvfrom进行数据的拷贝
- 异步IO(AIO)：应用进程把IO请求传给内核后，完全由内核去操作文件拷贝。内核完成相关操作后，会发信号告诉应用进程本次IO已经完成。
  ![](https://i.imgur.com/tEtn11o.png)
  用户进程发起aio_read操作之后，给内核传递描述符、缓冲区指针、缓冲区大小等，告诉内核当整个操作完成时，如何通知进程，然后就立刻去做其他事情了。当内核收到aio_read后，会立刻返回，然后内核开始等待数据准备，数据准备好以后，直接把数据拷贝到用户控件，然后再通知进程本次IO已经完成。
