layout:     post
title:      mysql索引优化
subtitle:   索引
date:       2019-08-015
author:     LHaisong
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - 数据库
## 索引  

> 索引的本质是一种数据结构

1. 聚集索引：按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，叶子节点也叫数据页，聚集索引能够在B+树叶子节点上直接找到数据。  
2. 非聚集索引：叶子节点不包含表的全部数据，叶子节点中存放着键值，以及一个书签用于告诉InnoDB引擎在哪可以找到这些行数据。 

## B+树索引和hash索引的区别  

1. 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；    
2. 从示意图中也能看到，如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；  
3. 同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；  
4. 哈希索引也不支持多列联合索引的最左匹配规则；  
5. B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。 

## B+树索引和B树索引的区别：

- B树和B+树最重要的一个区别就是B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。这就决定了B+树更适合用来存储外部数据，也就是所谓的磁盘数，那么Mysql如何衡量查询效率呢？磁盘IO次数，B-树（B类树）的特定就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数，当查询数据的时候，最好的情况就是很快找到目标索引，然后读取数据，使用B+树就能很好的完成这个目的，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时啊！），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。这是优点之一。  
- 另一个优点是什么，B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。  
  (数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）)  

## sql语句的执行过程  

[https://blog.csdn.net/sinat_32176267/article/details/83280206](https://blog.csdn.net/sinat_32176267/article/details/83280206)  

## mysql索引优化  

- 索引类型：  

1. 主键索引：特殊的唯一标识，不允许为空值，mysql会自动为主键列添加唯一索引，所以主键列不必再添加唯一索引  
2. 唯一索引：索引列必须唯一，但是允许有null  
   ALTER TABLE table_name ADD UNIQUE (column)
3. 普通索引：最基本的索引，没有限制，可以在表创建的时候创建也可以通过修改表结构进行创建  
   alter table table_name add index index_name(column_name);
4. 组合索引：一个索引包含多个列  
   alter table table_name add index index_name(column_name1,column_name2......);
5. 全文索引：全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用分词技术等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。  
   ALTER TABLE table_name ADD FULLTEXT (column)  
        

- 建立索引的原则：  

1. 最左前缀匹配原则：对于多列的组合索引，从列的最左边开始匹配，中间不能跳过，所以在创建组合索引时，在where子句中使用最频繁的放在左边，如果跳过最左边的列使用右边的列进行查询将导致全表扫描，索引无效。  
2. 选择区分度高的列作为索引，比如学号而不是性别  
3. in和=可以乱序，SQL的语句优化器会优化为索引可以识别的顺序  
4. 索引列不能参加计算，如果列参加计算的话每次索引时都会进行计算一次，成本很高。  
5. 能进行索引的扩展就不进行索引的创建，index(a)----->index(a,b)  
        

- 以下情况索引会失效：  

1. like的参数以通配符开头，如：like '%海松'   
2. where条件不符合最左前缀匹配原则  
3. 使用！=，<>操作符时  
4. 索引列参与计算  
5. 对字段进行null值判断  
6. 使用or来连接条件  
        

## 索引优化总结：[https://cloud.tencent.com/developer/article/1004912](https://cloud.tencent.com/developer/article/1004912)  

1. 避免使用select(*)，在解析的过程中会将'*' 依次转换成所有的列名，这个工作是通过查询数据字典完成的，这意味着将耗费更多的时间。  
2. order by语句优化：order by语句中的任何非索引列或有计算表达式的都会降低查询的速度
   ①重写order by语句使用索引②为索引项添加索引③绝对避免在子句中使用表达式  
3. group by优化：在group by之前将不需要的字段过滤掉，先where再group by  
4. 使用exists替代in  
5. join语句优化：如果应用程序有很多JOIN 查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制   

 使用explain优化SQL语句：[https://blog.csdn.net/zbw18297786698/article/details/54349046](https://blog.csdn.net/zbw18297786698/article/details/54349046)    
