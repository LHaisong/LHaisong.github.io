---
layout:     post
title:      mysql中的基本概念
subtitle:   存储引擎、锁
date:       2019-05-09
author:     LHaisong
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - 数据库
---

## 存储引擎
- InnoDB存储引擎：支持事务、行锁设计、支持外键，但是默认的读取不会产生锁。InnoDB通过使用多版本并发控制(MVCC)来获得高并发性，并实现了SQL默认的4种隔离级别，默认状态下是Repeattable，使用next-key locking来避免幻读问题，除此之外还提供了插入缓冲、二次写、自适应哈希索引、预读等高可用功能，表中数据的存储采用了聚集的方式。   

- MyISAM存储引擎：不支持事务、表锁设计，支持全文索引，它的缓冲池只缓存索引文件而不缓存数据文件  

## 锁的类别
- mysql中最主要有两种锁： 
 1. 共享锁：S Lock允许事务读一行数据，select ... from ... lock in share mode  加共享锁  
 2. 排它锁(悲观锁)：X Lock允许事务删除一行数据， select ... from ... for update 加排他锁  
 3. 乐观锁通过MVCC实现  
 4. InnoDB存储引擎为了支持在不同的粒度上进行加锁，而引入了一种额外的加锁方式，意向锁：  
    意向共享锁：IS Lock 获得表中某几行的共享锁  
    意向排它锁：IX Lock 获得表中某几行的排他锁 

- 锁的3中算法  
 1. Record Lock：单个行记录上的锁  
 2. Gap Lock：间隙锁，锁定一个范围，但不包含记录本身  
 3. Next-key Lock：前两者的集合，并且锁定本身，查询的索引含有唯一性属性时会进行降级为record lock仅锁住索引本身  

- mysql中的锁详情见：[https://blog.csdn.net/mysteryhaohao/article/details/51669741](https://blog.csdn.net/mysteryhaohao/article/details/51669741)

- 死锁的判定原理  
 1. 概念：两个或两个以上的事务在执行的过程中，因争夺资源而造成的一种互相等待的现象
 2. 死锁的检测：wait-for graph
 3. 死锁的解决:超时机制，当等待的时间超过某个设置的阈值时，其中一个事务进行回滚。 

## 非一致性锁定读
- 指的是innoDB引擎通过多版本并发控制来读取当前执行时间数据库中行数据，如果正在执行update或者delete操作，这时读取操作不会等待锁的释放，而是去读取一个快照数据(指的是改行之前版本的数据，听过undo实现)，这样大大提高了并发性。  

## 索引  
1. 聚集索引：按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，叶子节点也叫数据页，聚集索引能够在B+树叶子节点上直接找到数据。  
2. 非聚集索引：叶子节点不包含表的全部数据，叶子节点中存放着键值，以及一个书签用于告诉InnoDB引擎在哪可以找到这些行数据。 

## B+树索引和hash索引的区别  
1. 如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；    
2. 从示意图中也能看到，如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；  
3. 同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；  
4. 哈希索引也不支持多列联合索引的最左匹配规则；  
5. B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。 

## B+树索引和B树索引的区别：
- B树和B+树最重要的一个区别就是B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。这就决定了B+树更适合用来存储外部数据，也就是所谓的磁盘数，那么Mysql如何衡量查询效率呢？磁盘IO次数，B-树（B类树）的特定就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数，当查询数据的时候，最好的情况就是很快找到目标索引，然后读取数据，使用B+树就能很好的完成这个目的，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时啊！），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。这是优点之一。  
- 另一个优点是什么，B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这样遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。  
(数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）)  

## MySQL的中的日志  
- 错误日志：对MySQL的启动、运行、关闭过程进行记录，可通过错误日志定位MySQL存在的问题  
- 慢查询日志：定位存在问题的SQL语句，从而进行SQL语句层面的优化，在默认的情况下MySQL数据库并不启动慢查询日志，需要手动开启。  
- 查询日志：记录了所有对MySQL的请求信息。 
- 二进制日志：记录了对MySQL数据库执行更改的所有操作，但是不包括show和select这类没有对数据库进行修改的操作。  
  作用：1)恢复 2)复制 3)审计    
- 重做日志(redo)：重做日志文件用于实现事务的持久性。由两部分组成：  
  1. 是内存中的重做日志缓冲，是易失的  
  2. 是重做日志文件，是持久的，事务提交时必须将事务的日志全部写入重做日志文件进行持久化，待事务的commit操作完成才算完成，但是在                         数据库中也允许非持久化的操作，为了提高数据库的性能，可每隔一段时间才进行一次将事务日志从日志缓存中写入重做日志  
  3. 事务提交时的操作：  
     ①修改内存中对应的事务信息，并且将日志写入重做日志缓冲  
     ②调用fsync将确保日志都被从重做日志缓冲写入磁盘  
  > 二进制日志和重做日志的区别：二进制日志主要用来进行pointtotime的恢复及主从复制环境的建立，它在数据库的上层产生，是一种逻辑日志，对应的是SQL语句，它不只针对InNoDB存储引擎，数据库中的任何引擎对数据库的修改都会产生二进制日志，在事务提交完成后对它进行一次修改。重做日志在InNoDB存储引擎层产生，它是一种物理格式日志，记录的是对每个页的修改。  
  4. undo日志：用来帮助事务进行回滚和MVCC功能，当执行rollback语句时可利用undo信息将数据回滚到修改前的样子(并不是事务开始前的样子)  
  5. purge：用于完成delete和update的最终操作，当执行一条delete语句时，记录并不会直接被删除，而只是将delete flag标记为1，标记已删除，最终的删除任务由purge完成  

  
## 数据库的读写分离  
1. 原理：是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。  
2. why：数据库的写操作很费时，但是读操作很快，将这两个操作分开提高了查询的效率。  
3. when：数据库不一定要读写分离，如果程序使用数据库较多时，而更新少，查询多的情况下会考虑使用，利用数据库 主从同步 。可以减少数据库压力，提高性能。  
  
## 主从复制  
- 在实际的生产环境中，对数据库的读和写都在同一个数据库服务器中，是不能满足实际需求的。无论是在安全性、高可用性还是高并发等各个方面都是完全不能满足实际需求的。因此，通过主从复制的方式来同步数据，再通过读写分离来提升数据库的并发负载能力。mysql主从复制是对数据库中的数据、语句做备份。  
- MySQL主从复制是其最重要的功能之一。主从复制是指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器之中。对于多级复制，数据库服务器即可充当主机，也可充当从机。MySQL主从复制的基础是主服务器对数据库修改记录二进制日志，从服务器通过主服务器的二进制日志自动执行更新。  
- 主从复制的类型：
 1. 基于语句的复制：主服务器上面的语句在从服务器再执行一遍  
 2. 基于行的复制：把主服务器中改变的内容直接复制给从服务器，而不关心是由什么语句引起的  
 3. 混合类型的复制：MySQL默认使用基于语句的复制，当基于语句的复制会引发问题的时候就会使用基于行的复制，MySQL会自动进行选择  
主从复制的原理：[https://segmentfault.com/a/1190000008942618  ](https://segmentfault.com/a/1190000008942618   "主从复制")  
  
## sql语句的执行过程  
[https://blog.csdn.net/sinat_32176267/article/details/83280206](https://blog.csdn.net/sinat_32176267/article/details/83280206)  

## mysql索引优化  
- 索引类型：  
 1. 主键索引：特殊的唯一标识，不允许为空值，mysql会自动为主键列添加唯一索引，所以主键列不必再添加唯一索引  
 2. 唯一索引：索引列必须唯一，但是允许有null  
    ALTER TABLE table_name ADD UNIQUE (column)
 3. 普通索引：最基本的索引，没有限制，可以在表创建的时候创建也可以通过修改表结构进行创建  
    alter table table_name add index index_name(column_name);
 4. 组合索引：一个索引包含多个列  
    alter table table_name add index index_name(column_name1,column_name2......);
 5. 全文索引：全文索引（也称全文检索）是目前搜索引擎使用的一种关键技术。它能够利用分词技术等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。  
    ALTER TABLE table_name ADD FULLTEXT (column)  
         
- 建立索引的原则：  
 1. 最左前缀匹配原则：对于多列的组合索引，从列的最左边开始匹配，中间不能跳过，所以在创建组合索引时，在where子句中使用最频繁的放在左边，如果跳过                           最左边的列使用右边的列进行查询将导致全表扫描，索引无效。  
 2. 选择区分度高的列作为索引，比如学号而不是性别  
 3. in和=可以乱序，SQL的语句优化器会优化为索引可以识别的顺序  
 4. 索引列不能参加计算，如果列参加计算的话每次索引时都会进行计算一次，成本很高。  
 5. 能进行索引的扩展就不进行索引的创建，index(a)----->index(a,b)  
         
- 以下情况索引会失效：  
 1. like的参数以通配符开头，如：like '%海松'   
 2. where条件不符合最左前缀匹配原则  
 3. 使用！=，<>操作符时  
 4. 索引列参与计算  
 5. 对字段进行null值判断  
 6. 使用or来连接条件  
         
## 索引优化总结：[https://cloud.tencent.com/developer/article/1004912](https://cloud.tencent.com/developer/article/1004912)  
 1. 避免使用select(*)，在解析的过程中会将'*' 依次转换成所有的列名，这个工作是通过查询数据字典完成的，这意味着将耗费更多的时间。  
 2. order by语句优化：order by语句中的任何非索引列或有计算表达式的都会降低查询的速度
    ①重写order by语句使用索引②为索引项添加索引③绝对避免在子句中使用表达式  
 3. group by优化：在group by之前将不需要的字段过滤掉，先where再group by  
 4. 使用exists替代in  
 5. join语句优化：如果应用程序有很多JOIN 查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制   
 
 使用explain优化SQL语句：[https://blog.csdn.net/zbw18297786698/article/details/54349046](https://blog.csdn.net/zbw18297786698/article/details/54349046)    



   
    
  
