---
layout:     post
title:      java 锁优化
subtitle:   jdk1.6后对synchronized的优化
date:       2019-05-06
author:     LHaisong
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - java并发
---
## 前言
- java中的Synchronized关键字的实现非常简单，实现线程安全很容易，但是我们还必须注意到的是在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。庆幸的是在Java 6之后Java官方对从JVM层面对synchronized较大优化，所以现在的synchronized锁效率也优化得很不错了，Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁，接下来我们将简单了解一下Java官方在JVM层面对synchronized锁的优化。
# jvm层面对synchronized所做的优化  
- 自旋锁：在线程请求锁时，如果已有线程占有当前请求的锁，请求的线程并不马上放弃处理器的执行时间，而是稍等一会看是否有线程很快就会释放锁，可以让线程做           一个忙循环(自旋),自旋锁默认情况下是关闭的，需要用虚拟机参数来开启。   
- 锁消除：Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间
- 锁粗化：如果连续的零碎操作需要对同一个对象加锁，将会把整个锁同步范围扩大到整个操作序列外部，减少频繁互斥同步带来的性能损耗。    
- 轻量级锁：在代码进入同步块的时候，如果此同步对象未被锁定，虚拟机会在当前线程的栈帧中建立一个名为锁记录(lock record)的空间，用于存储锁对象目前。Mark Word拷贝(displaced mark word)，然后虚拟机将会使用CAS操作尝试将对象的Mark Word更新为指向lock record,如果这个操作成功则拥有了该对象的锁，Mark Word的锁标志为将会变成00，如果操作失败，虚拟机会检查对象的Mark Word是否指向了当前线程的栈帧，是则重入，否则说明当前锁              对象已经被其他线程抢占了，如果有多个线程竞争同一个锁则轻量级锁将不在有效，转变为重量级锁，后面线程阻塞。  
- 偏向锁： 当线程第一次获取锁对象的时候，虚拟机会把对象头的标志位设为01，进入偏向模式，同时使用CAS操作将持有偏向锁的线程的ID记录在Mark Word中，如果CAS操作成功，则以后持有偏向锁的线程进入这个锁相关的同步块时不用再进行任何操作，当有另外一个线程尝试获取这个锁时偏向模式结束，根据锁对象目前是否处于锁定状态，撤销偏向后恢复到轻量级锁状态或者无锁状态。 
