---
layout:     post
title:      java源程序编译、执行、优化.md
subtitle:   编译、运行
date:       2019-08-20
author:     LHaisong
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - jvm
---
 
# 源程序的编译

![](C:\Users\lenovo\Desktop\screeshot\37.png)

如上图所示，java源程序程序经过JAVAC编译程序编译后生成JAVA字节码（.class文件），源码编译分为以下3个过程：

- 解析与填充符号表
- 注解处理器
- 语义分析与字节码生成

# 运行

运行可分为两个阶段：加载字节码+运行

> class文件生成后由虚拟机把class文件加载(加载的时机？)进内存，并对数据进行验证、准备、解析、初始化最终形成可以被虚拟机直接使用的java类型，java语言类的加载、连接和初始化都是在运行期完成的，java字节码的运行有虚拟机自行引擎完成，如下图所示：

![](C:\Users\lenovo\Desktop\screeshot\38.png)

## 运行的两种方式:

- 1.解释执行：java程序最初是由解释器解释执行的，将机器码逐条读入，逐条解释翻译，然后执行，显然解释执行比直接执行二进制字节码慢，所以才引入了JIT技术
- 依旧是解释执行，不过不同的是引入了JIT优化技术，当虚拟机发现某段代码频繁运行的时候，会把它当做热点代码，在运行时，为了提高热点代码的运行效率，虚拟机会将这些热点代码编译成与平台相关的机器码，并进行各种优化，提高运行效率。

## 热点代码

热点代码有两类：

- 被多次调用的方法
- 被多次执行的循环体

热点代码的检测：

- 基于采样的热点检测

  > 虚拟机周期性的检测各个线程的栈顶，当发现某些方法经常出现在栈顶，则可以把它当做热点代码；
  >
  > 优缺点：实现简单、高效，但检测不准确

- 基于计数器的热点检测

  > 虚拟机为每个方法(代码块)建立一个计数器，统计方法执行的次数，设置一个阈值，当执行次数超过这个值的时候就把它当做热点代码
  >
  > 这种方法实现起来麻烦，但是很准确

  HotSpot使用的是第二种方法，设置了两类计数器：回边计数器（记录循环体的执行次数）和方法调用计数器（记录方法的执行次数）

  > 当方法执行时会检查有没有被JIT编译过的版本，有则直接使用本地代码来执行；没有则计数器+1，没超过阈值则解释执行，超过阈值则向JIT提交编译请求

# 优化技术

- 公共子表达式消除

  > 类似于表达式的化简，如果一个表达式计算过了，而且参与计算的变量的值未发生变化，那么这个表达式就可以被当做公子表达式消除

  ```java
  int d=(b*c)*12+a+(a+b*c)
  优化为：
  int e=b*c;
  int d=e*13+2a;
  ```

- 数组范围检查消除

- 方法内联

- 逃逸分析

  > 逃逸分析并不是直接优化的手段，但是可以为其它优化手段提供依据
  >
  > 基本行为：分析对象的动态作用域
  >
  > 当一个对象在方法中被定义后可能被其它方法引用，如作为参数传递到其它方法中，这种称称为方法逃逸。也有可能被其它线程访问到，这称为线程逃逸

  如果能证明一个对象不会逃逸，则可以为这个变量做一些高效的优化

  - 栈上分配：如果对象不会逃逸出方法就可以在栈上为对象分配内存，对象占用的空间随着栈帧的出栈而销毁，免去了垃圾回收消耗的时间
  - 同步消除：线程同步是耗时的，如果变量不会逃逸出线程，则对这个变量的读写就不会有竞争，这样对这个变量的同步操作就可以消除了
  - 标量替换：java中的对象是一个聚合量，如果一个对象不会逃逸，则程序在运行的时候可能就不会创建变量，而是选择在栈上直接创建若干个被使用到的成员变量供外部访问

  逃逸分析这项优化并不成熟，主要在于不能保证逃逸分析的性能收益一定大于它的消耗

参考博客：<https://blog.csdn.net/shenw ansangz/article/details/82422588>
