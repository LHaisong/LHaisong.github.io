---
layout:     post
title:      ConcurrentHashMap
subtitle:   ConcurrentHashMap重点知识总结
date:       2019-05-06
author:     LHaisong
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - Collections
---
## 1.ConcurrentHashMap介绍  
hashmap在高并发的情况下put操作会导致Entry链表形成环形数据结构，从而导致next永不为null而产生死循环；整体来说ConcurrentHashMap是HashMap的线程安全版本(*注意:hashmap允许加入null键 null值，而concurrenthashmap不允许*)，使用CAS操作和Synchronized关键字实现线程安全；  
## 2.重点变量介绍  
concurrenthashmap中的sizeCtl变量，在不同的值有不同的含义：  
默认为0，用来控制table的初始化和扩容操作： 
 - -1 代表table正在初始化  
 - -N 表示有N-1个线程正在进行扩容操作  
 - 其余情况：  
  1.如果table未初始化，表示table需要初始化的大小。  
  2.如果table初始化完成，表示table的容量，默认是table大小的0.75 倍，居然用这个公式算0.75（n - (n >>> 2)）。  
## 3.哪些地方使用了CAS操作？  
- 初始化table的时候，第一个线程使用CompareAndSwapInt()操作将sizectl的值修改为-1，因为只允许有一个线程进行初始化，所以其他线程可根据sizectl的值进行判断是否有线程在进行初始化   
- 插入值的时候，使用CompareAndSwapObject()方法修改值  
- 修改count值的时候，使用compareAndSwapLong()操作将binCount的值+1  
- 进行扩容时，通过CAS操作更新transferIndex的值，获取扩容任务  
## 4.ConcurrentHashMap中的重点操作：  
### 4.1 put()方法的过程：  
 - 根据hash=(h ^ (h >>> 16)) & HASH_BITS计算hash值;    
 - 在for死循环中使用CAS操作更新值;    
 - 首先判断table数组是否初始化，否？进行初始化操作;    
 *根据hash值计算出要插入table数组中的位置i=（n-1）&hash,如果i出处没有值，则直接使用CAS操作将节点插入到table中，跳出for循环;  
  如果i处为一个MOVE（hash=-1）标志节点，表示正在进行扩容操作，需要帮助扩容;  
  如果上面条件都不满足，表示i处为一个头结点，锁住头结点；判断如果是链表，进行链表的插入操作将node加到链表的末尾，key相同会覆盖原有的值；如果是红黑树，则按照红黑树的方法插入node;    
 - 根据binCount计算是否到达转换为红黑树的条件，是？则进行转换操作treeifyBin();  
 - 最后会执行addCount(1L, binCount)方法把binCount+1，并且进行扩容判断;  
### 4.2 transfer()过程(ConcurrentHashMap的扩容过程是支持多线程的,每次扩容都会调用transfer()方法进行table数组数据的迁移与复制);    
 - 根据CPU的核心数确定每个扩容的线程需要帮助处理多少个bucket,如果计算结果小于默认个数，则处理bucket个数为默认个数(默认情况下每个线程16个);  
 * 死循环开始转移。多线程并发转移就是在这个死循环中，根据一个 finishing 变量来判断，该变量为 true 表示扩容结束，否则继续扩容。  
 > 进入一个 while 循环，分配数组中一个桶的区间给线程，默认是 16. 从大到小进行分配。当拿到分配值后，进行 i-- 递减。这个 i 就是数组下标。（其中有一个 bound 参数，这个参数指的是该线程此次可以处理的区间的最小下标，超过这个下标，就需要重新领取区间或者结束扩容，还有一个 advance 参数，该参数指的是是否继续递减转移下一个桶，如果为 true，表示可以继续向后推进，反之，说明还没有处理好当前桶，不能推进)  
 > 出 while 循环，进 if 判断，判断扩容是否结束，如果扩容结束，清空临时变量，更新 table 变量，更新库容阈值。如果没完成，但已经无法领取区间（没了），该线程退出该方法，并将 sizeCtl 减一，表示扩容的线程少一个了。如果减完这个数以后，sizeCtl 回归了初始状态，表示没有线程再扩容了，该方法所有的线程扩容结束了。（这里主要是判断扩容任务是否结束，如果结束了就让线程退出该方法，并更新相关变量）。然后检查所有的桶，防止遗漏。
 > 如果没有完成任务，且 i 对应的槽位是空，尝试 CAS 插入占位符，让 putVal 方法的线程感知。  
 > 如果 i 对应的槽位不是空，且有了占位符，那么该线程跳过这个槽位，处理下一个槽位。  
 > 如果以上都是不是，说明这个槽位有一个实际的值。开始同步处理这个桶。  
 > 到这里，都还没有对桶内数据进行转移，只是计算了下标和处理区间，然后一些完成状态判断。同时，如果对应下标内没有数据或已经被占位了，就跳过了。  
 * 真正的开始数据的转移，处理每个桶的行为都是同步的。防止 putVal 的时候向链表插入数据。  
 > 如果这个桶是链表，那么就将这个链表根据 length 取于拆成两份，取于结果是 0 的放在新表的低位，取于结果是 1 放在新表的高位。  
 > 如果这个桶是红黑数，那么也拆成 2 份，方式和链表的方式一样，然后，判断拆分过的树的节点数量，如果数量小于等于 6，改造成链表。反之，继续使用红黑树结构。  
 > 到这里，就完成了一个桶从旧表转移到新表的过程。  
