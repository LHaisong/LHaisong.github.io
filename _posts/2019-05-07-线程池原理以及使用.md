---
layout:     post
title:      线程池
subtitle:   原理、使用
date:       2019-05-07
author:     LHaisong
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - java并发
---
## 线程池介绍
### 为什么使用线程池？
- 线程是一种稀缺资源，在高并发的情况下，如果无限制的创建线程不仅会浪费系统资源，而且会降低系统的安全性，合理的利用线程池对线程进行统一的分配、调优和监控很有必要，使用线程池主要有以下几个好处：  
  1)降低资源消耗    2)提高响应速度      3)提高线程的可管理性
### 线程池创建的方式：
-  Executors各个方法的弊端：  
   1) newFixedThreadPoolfPnewSingleThreadExecutor:主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至00M.  
   2) newCachedThreadPoolfPnewScheduledThreadPool:主要问題是线程数最大数是Integer.MAX_VALUE,可能会创建数置非常多的线程，甚至OOM。     
   3) ExecutorService pool = Executors.newFixedThreadPool(3);  
   推荐使用这种方式创建线程池，利于使用者理解各参数的作用，规避资源耗尽的风险;    
   4)ThreadPoolExecutor pool=new ThreadPoolExecutor(3,5,0L,TimeUnit.SECONDS,new ArrayBlockingQueue<Runnable>(3));   

### 创建线程池几个重要的参数
1. corePoolSize：核心线程数，当现线程池提交一个任务时，会创建一个线程去执行任务，直到线程数等于corePoolSize;  
2. maxPoolSize:线程中允许的最大线程数，如果提交的任务数大于核心线程数，则会把任务放进阻塞队列中去，前提是任务数小于maximumPoolSize,如果阻塞队列满了则将创建新的线程执行任务。  
3. keepAliveTime:线程空闲时的存活时间，默认情况下该参数在线程数大于corePoolSize的情况下才会有效;  
4. timeUnit:空闲时间单位;  
5. workQueue:阻塞队列，用于存放未执行的任务;几种常见的阻塞队列：  
 -  1) ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务；  
 -  2) LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；  
 -  3) SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene；  
 -  4) priorityBlockingQuene：具有优先级的无界阻塞队列；  
6. threadFactory: 创建线程的工厂，可以通过自定义线程工厂为线程指定名字  
7. handler：饱和策略，如果阻塞队列满了且没有可执行任务的线程，而任务又必须要提交，则必须要采用一种饱和策略来处理该任务：  
 -  1)AbortPolicy：直接抛出异常，默认策略；  
 -  2)CallerRunsPolicy：用调用者所在的线程来执行任务；  
 -  3)DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务；  
 -  4)DiscardPolicy：直接丢弃任务；  

## 线程池的原理
### 线程池状态参数
**需要注意的是，线程池使用Integer.size的高三位表示线程池的状态，低29位表示线程池的容量**  
![](https://i.imgur.com/W28OIbG.png)
- ctl是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两部分的信息: 线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，这里可以看到，使用了Integer类型来保存，高3位保存runState，低29位保存workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常量表示workerCount的上限值，大约是5亿。
- RUNNING(-1)：能接受新任务，也能处理阻塞队列中的任务;
- SHUTDOWN(0)：关闭状态，不接受新任务，但是可以执行阻塞队列中已经保存的任务;在RUNNING状态调用shutdown()方法到此状态;
- STOP(1)：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；
- TIDYING(2)：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。
- TERMINATED(3)：调用terminated()方法后进入该状态  

### 线程池excute()方法
![](https://i.imgur.com/j16P2nL.png)

## 参考
[https://fangjian0423.github.io/2016/03/22/java-threadpool-analysis/](https://fangjian0423.github.io/2016/03/22/java-threadpool-analysis/ "源码分析")
