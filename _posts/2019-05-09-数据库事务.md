---
layout:     post
title:      数据库事务
subtitle:   事务、隔离级别、以及每个级别存在的问题
date:       2019-05-09
author:     LHaisong
header-img: img/post-bg-re-vs-ng2.jpg
catalog: true
tags:
    - 数据库

---

## 什么是事务？

- 事务是一组SQL语句组成的逻辑处理单元
- 事务的ACID特征：

1. 原子性：事务是一个原子操作单元，要么全部成功，要么全部失败

   > 通过回滚实现，需要使用undo日志进行回滚

2. 一致性：在事务开始和完成时数据必须保持一致性状态，这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。

3. 隔离性：数据库系统提供了一定的隔离机制，保证事务之间的执行是独立的不会相互影响

4. 持久性：事务一旦提交，则对数据库的修改是永久性的

   > 当事务提交时，必须先将事务的所有日志写入重做日志缓冲(然后执行sync操作刷新到重做日志文件)中进行持久化，待事务的commit操作完成才算完成

## 并发事务带来的问题

- 丢失更新：指的是两个或多个事务选择同一行数据更新，由于每个事务都不知道其他事务的存在，所以有的事务所做的修改会被其它事务覆盖掉，这就是丢失更新问题
- 脏读：指一个事务选择一条数据更新，在这个事务提交之前这条数据就处于不一致状态，当其它事务读取改行时，就会读到脏数据
- 不可重复读：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。
- 幻读：指一个事务按照相同的条件读取以前查询过的数据，但是在这之前一件插入了其它符合条件的数据，这种现象就是幻读

## 事务的隔离级别

- 事务隔离级别

  在MySQL的众多存储引擎中，只有InnoDB支持事务，所有这里说的事务隔离级别指的是InnoDB下的事务隔离级别。

  读未提交：一个事务可以读取到另一个事务未提交的修改。这会带来脏读、幻读、不可重复读问题。（基本没用）

  读已提交：一个事务只能读取另一个事务已经提交的修改。其避免了脏读，但仍然存在不可重复读和幻读问题。

  可重复读：同一个事务中多次读取相同的数据返回的结果是一样的。其避免了脏读和不可重复读问题，但幻读依然存在。

  串行化：事务串行执行。避免了以上所有问题。


  ![](img/39.png)
  ![](https://raw.githubusercontent.com/LHaisong/LHaisong.github.io/tree/master/img/39.png)

> 在并发事务处理带来的问题中，“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。
>
> 在mysql中默认的隔离级别可重复读，不可重复读重点在于update和delete，而幻读的重点在于insert。

## MySQL数据库实现隔离级别的两种方式

- 在访问数据前对其加锁，防止其他事务操作数据

- 使用MVCC机制

  > 另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（MultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。

## 4中隔离级别，InnoDB如何实现的？

- read uncommitted：在这种隔离级别下select不加锁，也不是快照读

  > 并发最高，一致性最差

- read committed:

  1. 普通select是快照读
  2. 加锁的select、update、delete语句，除了在外键约束检查以及重复键检查时会封锁区间，其它时刻都是用记录锁
  3. 在这种情况下gap-lock、next-key lock会失效

- repeatable read：

  1. 普通select使用的是快照读，底层使用MVCC实现，一种不加锁的一致性读
  2. 加锁的select、update、delete等语句
  3. 唯一索引查询会使用记录锁(record lock)，但不会锁住范围，即不会使用gap lock与next-key lock
  4. 范围查询使用使用的是gap lock与next-key lock，可避免幻读

  > 需要注意的是read committed和repeatable read都使用到了快照读(MVCC)，但是两者对于快照数据的定义确是不一样的，repeatable read总是使用事务开始时的快照数据，而read committed总是使用最新的快照数据，这或许就是repeatable read能避免不可重复读的原因？

- serializable：在这种情况下所有的select都会默认加上共享锁

  > 读写一致性最好，但并发程度最低

## 一致性非锁定读

> 指的是InnoDB引擎通过多版本并发控制来读取当前执行时间数据库中行数据，如果正在执行update或者delete操作，这时读取操作不会等待锁的释放，而是去读取一个快照数据(指的是改行之前版本的数据，通过undo实现)，这样大大提高了并发性。  

## 锁的类别

- mysql中最主要有两种锁： 

1. 共享锁：S Lock允许事务读一行数据，select ... from ... lock in share mode  加共享锁  
2. 排它锁(悲观锁)：X Lock允许事务删除一行数据， select ... from ... for update 加排他锁  
3. 乐观锁通过MVCC实现  
4. InnoDB存储引擎为了支持在不同的粒度上进行加锁，而引入了一种额外的加锁方式，意向锁：  
   意向共享锁：IS Lock 获得表中某几行的共享锁  
   意向排它锁：IX Lock 获得表中某几行的排他锁 

- 锁的3中算法  

1. Record Locks（记录锁）：在索引记录上加锁。（没有索引则使用隐式主键）
2. Gap Locks（间隙锁）：在索引记录之间加锁，或者在第一个索引记录之前加锁，或者在最后一个索引记录之后加锁。
3. Next-Key Locks：在索引记录上加锁，并且在索引记录之前的间隙加锁。它相当于是Record Locks与Gap Locks的一个结合。

- mysql中的锁详情见：[https://blog.csdn.net/mysteryhaohao/article/details/51669741](https://blog.csdn.net/mysteryhaohao/article/details/51669741)
- 死锁的判定原理  

1. 概念：两个或两个以上的事务在执行的过程中，因争夺资源而造成的一种互相等待的现象
2. 死锁的检测：wait-for graph
3. 死锁的解决:超时机制，当等待的时间超过某个设置的阈值时，其中一个事务进行回滚。 







